DXRuby を使う
=============

Window 作成
-----------

キャラクター (画像) の表示
--------------------------


####


### Sprite データの処理 (画像データの画面内移動)

Sprite データは x, y という二つの座標データを持っている。
このデータは Sprite.new を実行した際に登録した二つの座標である。
画像が表示されている座標は Sprite データが持っている座標である。

因みに数学とは違い、座標の原点 0 は画面の一番左上である。
左上から右に X 軸プラス方向、下に Y 軸プラス方向となる。
Y 軸の扱いが数学のグラフとは異なるため注意が必要。

Sprite データの x, y 座標には Sprite データの変数名にそれぞれ ``.x`` ``.y`` をつけることでアクセスできる。
また、座標の上書きも出来るため、座標を少しずつずらすことでパラパラ漫画のようにキャラクタを移動させることが出来る。


```ruby
Window.loop do
  # sample_sprite という Sprite データの x 座標をプラス 1 する
  # += という記号の組み合わせは、左辺の値に右辺の値をプラスし、代入する意味を持つ
  # 他にも、-=, *=, /= などもある
  # += 1 の場合だと左辺の変数の値が 1 ずつ増加していく
  sample_sprite.x += 1

  # y も 1 ずつ増加
  sample_sprite.y += 1

  # Sprite.draw メソッドを使うと指定した Sprite データを画面に表示 (描画) することが出来る
  Sprite.draw(sample_sprite)
end
```

### キャラクタの操作

キャラクタの操作を行うために、キーボードの入力の受け付けを作る必要が出て来た。
DXRuby では、キーボード、マウス、ゲームパッドのそれぞれのアクション (要するにボタンを押したりする行為) を受け付けており、簡単に扱えるためこの機能を使ってキャラクタの移動を機能を作成する。

今回は、キャラクタの移動はキーボードから受け付けて行う。
キーボードの受付には、``Input.keyDown?`` というメソッドを使用する。
これは、メソッドの () 内で指定したキーの入力 (押し続けを含む) を真偽値で返す。
指定したキーを押していれば true という真をあらわすす値が返される。
指定したキーが押されていなければ false という偽をあらわす値が返される。

このメソッドだけでは、押しているのかどうかが分かるだけで、処理が変化しない (特定のボタンを押した時にキャラクタが移動しない) ため、条件分岐を使う。

条件分岐は、特定の条件を満たした時にだけ特殊な処理を実行するときに使用する。
今回の場合で言うと、キーボードの特定のキーを押すとキャラクタが移動する。
何も押していない場合は動かない、といった処理である。

```ruby
Window.loop do
  # Ruby の条件分岐は if `条件式` ~ end までの間に書く
  # K_L と言うのは、キーボードの L キーという意味
  # つまりキーボードの L のキーを押して (押し続けて) いたら true (真) である
  # true が返ってくると、if `条件式` ~ end の間に書いた処理が実行される
  # この場合は sample_sprite.x += 1 が実行される
  # 因みに、移動速度を変更したい場合は数値を変更すると良い
  if Input.keyDown?(K_L)
    sample_sprite.x += 1
  end

  # 後のキーの設定も行う
  if Input.keyDown?(K_K)
    sample_sprite.y -= 1
  end

  if Input.keyDown?(K_J)
    sample_sprite.y += 1
  end
  
  if Input.keyDown?(K_H)
    sample_sprite.x -= 1
  end

  # Sprite.draw メソッドを使うと指定した Sprite データを画面に表示 (描画) することが出来る
  Sprite.draw(sample_sprite)
end
```

### 衝突判定

衝突判定とは、オブジェクト(物体) とオブジェクトが
仮想的に衝突を起こしている条件を満たした場合に衝突が行われていることを判定する仕組み。
これが上手く動いていなかったりするとゲームキャラクタが壁をすり抜けるバグ等が発生したりする。

本来衝突判定は非常に面倒くさい処理を必要とする
 (皆の大嫌いな数学で、行列とベクトル辺りそれだけじゃないケド...) 
が、例によって簡単に判定できる仕組みがあるのでそちらを使用する。

まず衝突には二つ以上のオブジェクト (キャラクタ等のゲーム上に存在する物体) が必要なので、
Sprite データとして２つ用意してみる。
簡単に判定を行うには Sprite データとして扱わないと行けないので、
必ず Sprite データとして画像を用意すること。


```ruby
image_chara = Image.load_tiles("../image/character.png", 4, 4)
chara = Sprite.new(0, 0, image_chara[0])

image_box = Image.load_tiles("../image/colorbox.png", 6, 1)
box = Sprite.new(200, 200, image_box[0])

Window.loop do
  if Input.keyDown?(K_L)
    chara.x += 2
    # === を使って左辺と右辺を比較する事で衝突の判定をとることが出来る
    # この時両方のデータは Sprite データを持った変数か、配列であること
    # それ以外ではエラーとなる
    # 衝突が行われた場合は true が返ってくるため、この場合、
    # 直前にキャラクタの座標を x+2 しているため、その時に衝突した場合は
    # x+2 の処理を取りやめている
    # 結果的に、キャラクタは移動せずに壁にぶつかって止まっているように見える
    if chara === box
      chara.x -= 2
    end
  end

  # 後のキーの設定も行う
  if Input.keyDown?(K_K)
    chara.y -= 2
    if chara === box
      chara.y += 2
    end
  end

  if Input.keyDown?(K_J)
    chara.y += 2
    if chara === box
      chara.y -= 2
    end
  end

  if Input.keyDown?(K_H)
    chara.x -= 2
    if chara === box
      chara.x += 2
    end
  end

  # 画面の更新を行っている
  # この処理が実行されるまでは、オブジェクトにどれだけ変化が起こっていても
  # 見た目には反映されない
  Sprite.draw(chara)
  Sprite.draw(box)
end
```
